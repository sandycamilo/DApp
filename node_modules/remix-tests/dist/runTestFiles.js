"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runTestFiles = void 0;
var async_1 = __importDefault(require("async"));
var fileSystem_1 = __importDefault(require("./fileSystem"));
var testRunner_1 = require("./testRunner");
var colors_1 = __importDefault(require("colors"));
var compiler_1 = require("./compiler");
var deployer_1 = require("./deployer");
/**
 * @dev run test contract files (used for CLI)
 * @param filepath Path of file
 * @param isDirectory True, if path is a directory
 * @param web3 Web3
 * @param finalCallback optional callback to run finally
 * @param opts Options
 */
function runTestFiles(filepath, isDirectory, web3, finalCallback, opts) {
    if (finalCallback === void 0) { finalCallback = function () { }; }
    opts = opts || {};
    var sourceASTs = {};
    var Signale = require('signale').Signale;
    // signale configuration
    var options = {
        types: {
            result: {
                badge: '\t✓',
                label: '',
                color: 'greenBright'
            },
            name: {
                badge: '\n\t◼',
                label: '',
                color: 'white'
            },
            error: {
                badge: '\t✘',
                label: '',
                color: 'redBright'
            }
        }
    };
    var signale = new Signale(options);
    var accounts = opts['accounts'] || null;
    async_1.default.waterfall([
        function getAccountList(next) {
            if (accounts)
                return next(null);
            web3.eth.getAccounts(function (_err, _accounts) {
                accounts = _accounts;
                next(null);
            });
        },
        function compile(next) {
            compiler_1.compileFileOrFiles(filepath, isDirectory, { accounts: accounts }, next);
        },
        function deployAllContracts(compilationResult, asts, next) {
            // Extract AST of test contract file source
            for (var filename in asts) {
                if (filename.endsWith('_test.sol'))
                    sourceASTs[filename] = asts[filename].ast;
            }
            deployer_1.deployAll(compilationResult, web3, false, function (err, contracts) {
                if (err) {
                    next(err);
                }
                next(null, compilationResult, contracts);
            });
        },
        function determineTestContractsToRun(compilationResult, contracts, next) {
            var contractsToTest = [];
            var contractsToTestDetails = [];
            var gatherContractsFrom = function (filename) {
                if (!filename.endsWith('_test.sol')) {
                    return;
                }
                try {
                    Object.keys(compilationResult[filename]).forEach(function (contractName) {
                        contractsToTest.push(contractName);
                        contractsToTestDetails.push(compilationResult[filename][contractName]);
                    });
                }
                catch (e) {
                    console.error(e);
                }
            };
            if (isDirectory) {
                fileSystem_1.default.walkSync(filepath, function (foundpath) {
                    gatherContractsFrom(foundpath);
                });
            }
            else {
                gatherContractsFrom(filepath);
            }
            next(null, contractsToTest, contractsToTestDetails, contracts);
        },
        function runTests(contractsToTest, contractsToTestDetails, contracts, next) {
            var totalPassing = 0;
            var totalFailing = 0;
            var totalTime = 0;
            var errors = [];
            var _testCallback = function (err, result) {
                if (err)
                    throw err;
                if (result.type === 'contract') {
                    signale.name(result.value.white);
                }
                else if (result.type === 'testPass') {
                    signale.result(result.value);
                }
                else if (result.type === 'testFailure') {
                    signale.result(result.value.red);
                    errors.push(result);
                }
            };
            var _resultsCallback = function (_err, result, cb) {
                totalPassing += result.passingNum;
                totalFailing += result.failureNum;
                totalTime += result.timePassed;
                cb();
            };
            async_1.default.eachOfLimit(contractsToTest, 1, function (contractName, index, cb) {
                try {
                    var fileAST = sourceASTs[contracts[contractName]['filename']];
                    testRunner_1.runTest(contractName, contracts[contractName], contractsToTestDetails[index], fileAST, { accounts: accounts }, _testCallback, function (err, result) {
                        if (err) {
                            console.log(err);
                            return cb(err);
                        }
                        _resultsCallback(null, result, cb);
                    });
                }
                catch (e) {
                    console.error(e);
                }
            }, function (err) {
                if (err) {
                    return next(err);
                }
                console.log('\n');
                if (totalPassing > 0) {
                    console.log(colors_1.default.green(totalPassing + ' passing ') + colors_1.default.grey('(' + totalTime + 's)'));
                }
                if (totalFailing > 0) {
                    console.log(colors_1.default.red(totalFailing + ' failing'));
                }
                console.log('');
                errors.forEach(function (error, index) {
                    console.log('  ' + (index + 1) + ') ' + error.context + ' ' + error.value);
                    console.log('');
                    console.log(colors_1.default.red('\t error: ' + error.errMsg));
                });
                console.log('');
                next();
            });
        }
    ], finalCallback);
}
exports.runTestFiles = runTestFiles;
//# sourceMappingURL=runTestFiles.js.map