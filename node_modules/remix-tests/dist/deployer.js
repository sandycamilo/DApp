"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.deployAll = void 0;
var async_1 = __importDefault(require("async"));
var remix_lib_1 = require("remix-lib");
/**
 * @dev Deploy all contracts from compilation result
 * @param compileResult compilation result
 * @param web3 web3 object
 * @param withDoubleGas If true, try deployment with gas double of estimation (used for Out-of-gas error only)
 * @param callback Callback
 */
function deployAll(compileResult, web3, withDoubleGas, callback) {
    var compiledObject = {};
    var contracts = {};
    var accounts = [];
    async_1.default.waterfall([
        function getAccountList(next) {
            web3.eth.getAccounts(function (_err, _accounts) {
                accounts = _accounts;
                next();
            });
        },
        function getContractData(next) {
            for (var contractFile in compileResult) {
                for (var contractName in compileResult[contractFile]) {
                    var contract = compileResult[contractFile][contractName];
                    var className = contractName;
                    var filename = contractFile;
                    var abi = contract.abi;
                    var code = contract.evm.bytecode.object;
                    compiledObject[className] = {};
                    compiledObject[className].abi = abi;
                    compiledObject[className].code = code;
                    compiledObject[className].filename = filename;
                    compiledObject[className].className = className;
                    compiledObject[className].raw = contract;
                    if (contractFile.endsWith('_test.sol')) {
                        compiledObject[className].isTest = true;
                    }
                }
            }
            next();
        },
        function determineContractsToDeploy(next) {
            var contractsToDeploy = ['Assert'];
            var allContracts = Object.keys(compiledObject);
            for (var _i = 0, allContracts_1 = allContracts; _i < allContracts_1.length; _i++) {
                var contractName = allContracts_1[_i];
                if (contractName === 'Assert') {
                    continue;
                }
                if (compiledObject[contractName].isTest) {
                    contractsToDeploy.push(contractName);
                }
            }
            next(null, contractsToDeploy);
        },
        function deployContracts(contractsToDeploy, next) {
            var deployRunner = function (deployObject, contractObject, contractName, filename, callback) {
                deployObject.estimateGas().then(function (gasValue) {
                    var gasBase = Math.ceil(gasValue * 1.2);
                    var gas = withDoubleGas ? gasBase * 2 : gasBase;
                    deployObject.send({
                        from: accounts[0],
                        gas: gas
                    }).on('receipt', function (receipt) {
                        contractObject.options.address = receipt.contractAddress;
                        contractObject.options.from = accounts[0];
                        contractObject.options.gas = 5000 * 1000;
                        compiledObject[contractName].deployedAddress = receipt.contractAddress;
                        contracts[contractName] = contractObject;
                        contracts[contractName].filename = filename;
                        callback(null, { result: { createdAddress: receipt.contractAddress } }); // TODO this will only work with JavaScriptV VM
                    }).on('error', function (err) {
                        console.error(err);
                        callback(err);
                    });
                });
            };
            async_1.default.eachOfLimit(contractsToDeploy, 1, function (contractName, index, nextEach) {
                var contract = compiledObject[contractName];
                var encodeDataFinalCallback = function (error, contractDeployData) {
                    if (error)
                        return nextEach(error);
                    try {
                        var contractObject = new web3.eth.Contract(contract.abi);
                        var deployObject = contractObject.deploy({ arguments: [], data: '0x' + contractDeployData.dataHex });
                        deployRunner(deployObject, contractObject, contractName, contract.filename, function (error) { nextEach(error); });
                    }
                    catch (e) {
                        throw e;
                    }
                };
                var encodeDataStepCallback = function (msg) { console.dir(msg); };
                var encodeDataDeployLibraryCallback = function (libData, callback) {
                    var abi = compiledObject[libData.data.contractName].abi;
                    var code = compiledObject[libData.data.contractName].code;
                    var libraryObject = new web3.eth.Contract(abi);
                    var deployObject = libraryObject.deploy({ arguments: [], data: '0x' + code });
                    deployRunner(deployObject, libraryObject, libData.data.contractName, contract.filename, callback);
                };
                var funAbi = null; // no need to set the abi for encoding the constructor
                var params = ''; // we suppose that the test contract does not have any param in the constructor
                remix_lib_1.execution.txFormat.encodeConstructorCallAndDeployLibraries(contractName, contract.raw, compileResult, params, funAbi, encodeDataFinalCallback, encodeDataStepCallback, encodeDataDeployLibraryCallback);
            }, function (err) {
                if (err)
                    next(err);
                next(null, contracts);
            });
        }
    ], callback);
}
exports.deployAll = deployAll;
//# sourceMappingURL=deployer.js.map