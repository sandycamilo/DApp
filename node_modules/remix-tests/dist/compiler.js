"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.compileContractSources = exports.compileFileOrFiles = void 0;
var fileSystem_1 = __importDefault(require("./fileSystem"));
var async_1 = __importDefault(require("async"));
var path_1 = __importDefault(require("path"));
var RemixCompiler = require('remix-solidity').Compiler;
var types_1 = require("./types");
function regexIndexOf(inputString, regex, startpos) {
    if (startpos === void 0) { startpos = 0; }
    var indexOf = inputString.substring(startpos).search(regex);
    return (indexOf >= 0) ? (indexOf + (startpos)) : indexOf;
}
function writeTestAccountsContract(accounts) {
    var testAccountContract = require('../sol/tests_accounts.sol.js');
    var body = "address[" + accounts.length + "] memory accounts;";
    if (!accounts.length)
        body += ';';
    else {
        accounts.map(function (address, index) {
            body += "\naccounts[" + index + "] = " + address + ";\n";
        });
    }
    return testAccountContract.replace('>accounts<', body);
}
/**
 * @dev Check if path includes name of a remix test file
 * @param path file path to check
 */
function isRemixTestFile(path) {
    return ['tests.sol', 'remix_tests.sol', 'remix_accounts.sol'].some(function (name) { return path.includes(name); });
}
/**
 * @dev Process file to prepare sources object to be passed in solc compiler input
 *
 * See: https://solidity.readthedocs.io/en/latest/using-the-compiler.html#input-description
 *
 * @param filePath path of file to process
 * @param sources existing 'sources' object in which keys are the "global" names of the source files and
 *                value is object containing content of corresponding file with under key 'content'
 * @param isRoot True, If file is a root test contract file which is getting processed, not an imported file
 */
function processFile(filePath, sources, isRoot) {
    if (isRoot === void 0) { isRoot = false; }
    var importRegEx = /import ['"](.+?)['"];/g;
    var group = null;
    var isFileAlreadyInSources = Object.keys(sources).includes(filePath);
    // Return if file is a remix test file or already processed
    if (isRemixTestFile(filePath) || isFileAlreadyInSources)
        return;
    var content = fileSystem_1.default.readFileSync(filePath, { encoding: 'utf-8' });
    var testFileImportRegEx = /^(import)\s['"](remix_tests.sol|tests.sol)['"];/gm;
    // import 'remix_tests.sol', if file is a root test contract file and doesn't already have it 
    if (isRoot && filePath.endsWith('_test.sol') && regexIndexOf(content, testFileImportRegEx) < 0) {
        var includeTestLibs = '\nimport \'remix_tests.sol\';\n';
        content = includeTestLibs.concat(content);
    }
    sources[filePath] = { content: content };
    importRegEx.exec(''); // Resetting state of RegEx
    // Process each 'import' in file content
    while (group = importRegEx.exec(content)) {
        var importedFile = group[1];
        var importedFilePath = path_1.default.join(path_1.default.dirname(filePath), importedFile);
        processFile(importedFilePath, sources);
    }
}
var userAgent = (typeof (navigator) !== 'undefined') && navigator.userAgent ? navigator.userAgent.toLowerCase() : '-';
var isBrowser = !(typeof (window) === 'undefined' || userAgent.indexOf(' electron/') > -1);
/**
 * @dev Compile file or files before running tests (used for CLI execution)
 * @param filename Name of file
 * @param isDirectory True, if path is a directory
 * @param opts Options
 * @param cb Callback
 *
 * TODO: replace this with remix's own compiler code
 */
function compileFileOrFiles(filename, isDirectory, opts, cb) {
    var compiler;
    var accounts = opts.accounts || [];
    var sources = {
        'tests.sol': { content: require('../sol/tests.sol.js') },
        'remix_tests.sol': { content: require('../sol/tests.sol.js') },
        'remix_accounts.sol': { content: writeTestAccountsContract(accounts) }
    };
    var filepath = (isDirectory ? filename : path_1.default.dirname(filename));
    try {
        if (!isDirectory && fileSystem_1.default.existsSync(filename)) {
            if (filename.split('.').pop() === 'sol') {
                processFile(filename, sources, true);
            }
            else {
                throw new Error('Not a solidity file');
            }
        }
        else {
            // walkSync only if it is a directory
            fileSystem_1.default.walkSync(filepath, function (foundpath) {
                // only process .sol files
                if (foundpath.split('.').pop() === 'sol') {
                    processFile(foundpath, sources, true);
                }
            });
        }
    }
    catch (e) {
        throw e;
    }
    finally {
        async_1.default.waterfall([
            function loadCompiler(next) {
                compiler = new RemixCompiler();
                compiler.onInternalCompilerLoaded();
                // compiler.event.register('compilerLoaded', this, function (version) {
                next();
                // });
            },
            function doCompilation(next) {
                // @ts-ignore
                compiler.event.register('compilationFinished', this, function (success, data, source) {
                    next(null, data);
                });
                compiler.compile(sources, filepath);
            }
        ], function (err, result) {
            var error = [];
            if (result.error)
                error.push(result.error);
            var errors = (result.errors || error).filter(function (e) { return e.type === 'Error' || e.severity === 'error'; });
            if (errors.length > 0) {
                if (!isBrowser)
                    require('signale').fatal(errors);
                return cb(new types_1.CompilationErrors(errors));
            }
            cb(err, result.contracts, result.sources); //return callback with contract details & ASTs
        });
    }
}
exports.compileFileOrFiles = compileFileOrFiles;
/**
 * @dev Compile contract source before running tests (used for IDE tests execution)
 * @param sources sources
 * @param compilerConfig current compiler configuration
 * @param importFileCb Import file callback
 * @param opts Options
 * @param cb Callback
 */
function compileContractSources(sources, compilerConfig, importFileCb, opts, cb) {
    var compiler, filepath;
    var accounts = opts.accounts || [];
    // Iterate over sources keys. Inject test libraries. Inject test library import statements.
    if (!('remix_tests.sol' in sources) && !('tests.sol' in sources)) {
        sources['tests.sol'] = { content: require('../sol/tests.sol.js') };
        sources['remix_tests.sol'] = { content: require('../sol/tests.sol.js') };
        sources['remix_accounts.sol'] = { content: writeTestAccountsContract(accounts) };
    }
    var testFileImportRegEx = /^(import)\s['"](remix_tests.sol|tests.sol)['"];/gm;
    var includeTestLibs = '\nimport \'remix_tests.sol\';\n';
    for (var file in sources) {
        var c = sources[file].content;
        if (file.endsWith('_test.sol') && c && regexIndexOf(c, testFileImportRegEx) < 0) {
            sources[file].content = includeTestLibs.concat(c);
        }
    }
    async_1.default.waterfall([
        function loadCompiler(next) {
            var currentCompilerUrl = compilerConfig.currentCompilerUrl, evmVersion = compilerConfig.evmVersion, optimize = compilerConfig.optimize, usingWorker = compilerConfig.usingWorker;
            compiler = new RemixCompiler(importFileCb);
            compiler.set('evmVersion', evmVersion);
            compiler.set('optimize', optimize);
            compiler.loadVersion(usingWorker, currentCompilerUrl);
            // @ts-ignore
            compiler.event.register('compilerLoaded', this, function (version) {
                next();
            });
        },
        function doCompilation(next) {
            // @ts-ignore
            compiler.event.register('compilationFinished', this, function (success, data, source) {
                next(null, data);
            });
            compiler.compile(sources, filepath);
        }
    ], function (err, result) {
        var error = [];
        if (result.error)
            error.push(result.error);
        var errors = (result.errors || error).filter(function (e) { return e.type === 'Error' || e.severity === 'error'; });
        if (errors.length > 0) {
            if (!isBrowser)
                require('signale').fatal(errors);
            return cb(new types_1.CompilationErrors(errors));
        }
        cb(err, result.contracts, result.sources); // return callback with contract details & ASTs
    });
}
exports.compileContractSources = compileContractSources;
//# sourceMappingURL=compiler.js.map