"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runTest = void 0;
var async_1 = __importDefault(require("async"));
var changeCase = __importStar(require("change-case"));
var web3_1 = __importDefault(require("web3"));
/**
 * @dev Get function name using method signature
 * @param signature siganture
 * @param methodIdentifiers Object containing all methods identifier
 */
function getFunctionFullName(signature, methodIdentifiers) {
    for (var method in methodIdentifiers) {
        if (signature.replace('0x', '') === methodIdentifiers[method].replace('0x', '')) {
            return method;
        }
    }
    return null;
}
/**
 * @dev Check if function is constant using function ABI
 * @param funcABI function ABI
 */
function isConstant(funcABI) {
    return (funcABI.constant || funcABI.stateMutability === 'view' || funcABI.stateMutability === 'pure');
}
/**
 * @dev Check if function is payable using function ABI
 * @param funcABI function ABI
 */
function isPayable(funcABI) {
    return (funcABI.payable || funcABI.stateMutability === 'payable');
}
/**
 * @dev Get overrided sender provided using natspec
 * @param userdoc method user documentaion
 * @param signature signature
 * @param methodIdentifiers Object containing all methods identifier
 */
function getOverridedSender(userdoc, signature, methodIdentifiers) {
    var fullName = getFunctionFullName(signature, methodIdentifiers);
    var senderRegex = /#sender: account-+(\d)/g;
    var accountIndex = fullName && userdoc.methods[fullName] ? senderRegex.exec(userdoc.methods[fullName].notice) : null;
    return fullName && accountIndex ? accountIndex[1] : null;
}
/**
 * @dev Get value provided using natspec
 * @param userdoc method user documentaion
 * @param signature signature
 * @param methodIdentifiers Object containing all methods identifier
 */
function getProvidedValue(userdoc, signature, methodIdentifiers) {
    var fullName = getFunctionFullName(signature, methodIdentifiers);
    var valueRegex = /#value: (\d+)/g;
    var value = fullName && userdoc.methods[fullName] ? valueRegex.exec(userdoc.methods[fullName].notice) : null;
    return fullName && value ? value[1] : null;
}
/**
 * @dev returns functions of a test contract file in same sequence they appear in file (using passed AST)
 * @param fileAST AST of test contract file source
 * @param testContractName Name of test contract
 */
function getAvailableFunctions(fileAST, testContractName) {
    var funcList = [];
    if (fileAST.nodes && fileAST.nodes.length > 0) {
        var contractAST = fileAST.nodes.filter(function (node) { return node.name === testContractName && node.nodeType === 'ContractDefinition'; });
        if (contractAST.length > 0 && contractAST[0].nodes) {
            var funcNodes = contractAST[0].nodes.filter(function (node) { return ((node.kind === "function" && node.nodeType === "FunctionDefinition") || (node.nodeType === "FunctionDefinition")); });
            funcList = funcNodes.map(function (node) { return node.name; });
        }
    }
    return funcList;
}
/**
 * @dev returns ABI of passed method list from passed interface
 * @param jsonInterface Json Interface
 * @param funcList Methods to extract the interface of
 */
function getTestFunctionsInterface(jsonInterface, funcList) {
    var functionsInterface = [];
    var specialFunctions = ['beforeAll', 'beforeEach', 'afterAll', 'afterEach'];
    var _loop_1 = function (func) {
        if (!specialFunctions.includes(func)) {
            var funcInterface = jsonInterface.find(function (node) { return node.type === 'function' && node.name === func; });
            if (funcInterface)
                functionsInterface.push(funcInterface);
        }
    };
    for (var _i = 0, funcList_1 = funcList; _i < funcList_1.length; _i++) {
        var func = funcList_1[_i];
        _loop_1(func);
    }
    return functionsInterface;
}
/**
 * @dev returns ABI of special functions from passed interface
 * @param jsonInterface Json Interface
 */
function getSpecialFunctionsInterface(jsonInterface) {
    var specialFunctionsInterface = {};
    var funcList = ['beforeAll', 'beforeEach', 'afterAll', 'afterEach'];
    var _loop_2 = function (func) {
        var funcInterface = jsonInterface.find(function (node) { return node.type === 'function' && node.name === func; });
        if (funcInterface) {
            specialFunctionsInterface[func] = funcInterface;
        }
    };
    for (var _i = 0, funcList_2 = funcList; _i < funcList_2.length; _i++) {
        var func = funcList_2[_i];
        _loop_2(func);
    }
    return specialFunctionsInterface;
}
/**
 * @dev Prepare a list of tests to run using test contract file ABI, AST & contract name
 * @param jsonInterface File JSON interface
 * @param fileAST File AST
 * @param testContractName Test contract name
 */
function createRunList(jsonInterface, fileAST, testContractName) {
    var availableFunctions = getAvailableFunctions(fileAST, testContractName);
    var testFunctionsInterface = getTestFunctionsInterface(jsonInterface, availableFunctions);
    var specialFunctionsInterface = getSpecialFunctionsInterface(jsonInterface);
    var runList = [];
    if (availableFunctions.includes('beforeAll')) {
        var func = specialFunctionsInterface['beforeAll'];
        runList.push({ name: 'beforeAll', inputs: func.inputs, signature: func.signature, type: 'internal', constant: isConstant(func), payable: isPayable(func) });
    }
    for (var _i = 0, testFunctionsInterface_1 = testFunctionsInterface; _i < testFunctionsInterface_1.length; _i++) {
        var func = testFunctionsInterface_1[_i];
        if (availableFunctions.includes('beforeEach')) {
            var func_1 = specialFunctionsInterface['beforeEach'];
            runList.push({ name: 'beforeEach', inputs: func_1.inputs, signature: func_1.signature, type: 'internal', constant: isConstant(func_1), payable: isPayable(func_1) });
        }
        if (func.name && func.inputs)
            runList.push({ name: func.name, inputs: func.inputs, signature: func.signature, type: 'test', constant: isConstant(func), payable: isPayable(func) });
        if (availableFunctions.indexOf('afterEach') >= 0) {
            var func_2 = specialFunctionsInterface['afterEach'];
            runList.push({ name: 'afterEach', inputs: func_2.inputs, signature: func_2.signature, type: 'internal', constant: isConstant(func_2), payable: isPayable(func_2) });
        }
    }
    if (availableFunctions.indexOf('afterAll') >= 0) {
        var func = specialFunctionsInterface['afterAll'];
        runList.push({ name: 'afterAll', inputs: func.inputs, signature: func.signature, type: 'internal', constant: isConstant(func), payable: isPayable(func) });
    }
    return runList;
}
function runTest(testName, testObject, contractDetails, fileAST, opts, testCallback, resultsCallback) {
    var passingNum = 0;
    var failureNum = 0;
    var timePassed = 0;
    var isJSONInterfaceAvailable = testObject && testObject.options && testObject.options.jsonInterface;
    if (!isJSONInterfaceAvailable)
        return resultsCallback(new Error('Contract interface not available'), { passingNum: passingNum, failureNum: failureNum, timePassed: timePassed });
    var runList = createRunList(testObject.options.jsonInterface, fileAST, testName);
    var web3 = new web3_1.default();
    var accts = {
        type: 'accountList',
        value: opts.accounts
    };
    testCallback(undefined, accts);
    var resp = {
        type: 'contract',
        value: testName,
        filename: testObject.filename
    };
    testCallback(undefined, resp);
    async_1.default.eachOfLimit(runList, 1, function (func, index, next) {
        var sender = null;
        if (func.signature) {
            sender = getOverridedSender(contractDetails.userdoc, func.signature, contractDetails.evm.methodIdentifiers);
            if (opts.accounts && sender) {
                sender = opts.accounts[sender];
            }
        }
        var sendParams = null;
        if (sender)
            sendParams = { from: sender };
        if (func.inputs && func.inputs.length > 0)
            return resultsCallback(new Error("Method '" + func.name + "' can not have parameters inside a test contract"), { passingNum: passingNum, failureNum: failureNum, timePassed: timePassed });
        var method = testObject.methods[func.name].apply(testObject.methods[func.name], []);
        var startTime = Date.now();
        if (func.constant) {
            method.call(sendParams).then(function (result) {
                var time = (Date.now() - startTime) / 1000.0;
                if (result) {
                    var resp_1 = {
                        type: 'testPass',
                        value: changeCase.sentenceCase(func.name),
                        time: time,
                        context: testName
                    };
                    testCallback(undefined, resp_1);
                    passingNum += 1;
                    timePassed += time;
                }
                else {
                    var resp_2 = {
                        type: 'testFailure',
                        value: changeCase.sentenceCase(func.name),
                        time: time,
                        errMsg: 'function returned false',
                        context: testName
                    };
                    testCallback(undefined, resp_2);
                    failureNum += 1;
                }
                next();
            });
        }
        else {
            if (func.payable) {
                var value = getProvidedValue(contractDetails.userdoc, func.signature, contractDetails.evm.methodIdentifiers);
                if (value) {
                    if (sendParams)
                        sendParams.value = value;
                    else
                        sendParams = { value: value };
                }
            }
            method.send(sendParams).on('receipt', function (receipt) {
                try {
                    var time = (Date.now() - startTime) / 1000.0;
                    var topic = web3_1.default.utils.sha3('AssertionEvent(bool,string)');
                    var testPassed = false;
                    for (var i in receipt.events) {
                        var event_1 = receipt.events[i];
                        if (event_1.raw.topics.indexOf(topic) >= 0) {
                            var testEvent = web3.eth.abi.decodeParameters(['bool', 'string'], event_1.raw.data);
                            if (!testEvent[0]) {
                                var resp_3 = {
                                    type: 'testFailure',
                                    value: changeCase.sentenceCase(func.name),
                                    time: time,
                                    errMsg: testEvent[1],
                                    context: testName
                                };
                                testCallback(undefined, resp_3);
                                failureNum += 1;
                                return next();
                            }
                            testPassed = true;
                        }
                    }
                    if (testPassed) {
                        var resp_4 = {
                            type: 'testPass',
                            value: changeCase.sentenceCase(func.name),
                            time: time,
                            context: testName
                        };
                        testCallback(undefined, resp_4);
                        passingNum += 1;
                    }
                    return next();
                }
                catch (err) {
                    console.error(err);
                    return next(err);
                }
            }).on('error', function (err) {
                var time = (Date.now() - startTime) / 1000.0;
                var resp = {
                    type: 'testFailure',
                    value: changeCase.sentenceCase(func.name),
                    time: time,
                    errMsg: err.message,
                    context: testName
                };
                testCallback(undefined, resp);
                failureNum += 1;
                return next();
            });
        }
    }, function (error) {
        resultsCallback(error, { passingNum: passingNum, failureNum: failureNum, timePassed: timePassed });
    });
}
exports.runTest = runTest;
//# sourceMappingURL=testRunner.js.map